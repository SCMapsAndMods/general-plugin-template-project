#summary Documentation on the UnitFinder class.

Class header file: [http://code.google.com/p/gptp/source/browse/trunk/GPTP/src/SCBW/UnitFinder.h SCBW/UnitFinder.h]

The `UnitFinder` class utilizies the internal data structures that !StarCraft uses to efficiently search for units within a portion of the map. Several of its methods support callback functions and functors that can process these units.

Note: This class internally handles an array of 1700 <tt>[CUnit]</tt> pointers, so instantiating it every time may become expensive. Consider declaring the `UnitFinder` variable as static.

<wiki:toc max_depth="2" />

= Methods =

== `UnitFinder` ==

{{{
UnitFinder();
UnitFinder(int left, int top, int right, int bottom);
}}}

Constructors for the `UnitFinder` class. The four-parameter version immediately calls [#search UnitFinder::search()].

== `search` ==

{{{
void search(int left, int top, int right, int bottom);
}}}

Searches for all units within the given bounds, using !StarCraft's internal data structures. This is much more efficient than manually looping through the entire unit table or linked list. The search result is stored in the current instance of the class, and can be used with other member functions.

== `getUnitCount` ==

{{{
int getUnitCount() const;
}}}

Returns the number of units found by [#search UnitFinder::search()]. If no searches have been conducted, returns 0.

== `getUnit` ==

{{{
CUnit* getUnit(int index) const;
}}}

Returns the unit at the given index. Invalid index returns `nullptr` instead.


== `forEach` ==

{{{
template <class Callback>
void forEach(Callback &func) const;
}}}

Iterates through all units found, calling `func()` once for each unit.

This example increases the HP of all units found by 10:
{{{
finder.forEach([] (CUnit *unit) {
  unit->setHp(unit->hitPoints + 2560);
});
}}}

== `getFirst` ==

{{{
template <class Callback>
CUnit* getFirst(Callback &match) const;
}}}

Returns the first unit for which `match()` returns true. If there are no matches, returns `nullptr`.

This example searches for a Zerg Defiler in an area:
{{{
CUnit *defiler = finder.getFirst([] (CUnit *unit) {
  if (unit->id == UnitId::defiler)
    return true;
  else
    return false;
});
}}}

== `getBest` ==

{{{
template <class Callback>
CUnit* getBest(Callback &score) const;
}}}

Returns the unit for which `score()` returns the highest nonnegative score. If a unit receives negative score, it is excluded from the search. If there are no units, returns `nullptr`.


This example searches for an Ultralisk with the most HP in an area:
{{{
CUnit *bestUltralisk = finder.getBest([] (CUnit *unit) {
  if (unit->id == UnitId::ultralisk)
    return unit->hitPoints; //The unit's HP serves as the "score"
  else
    return -1; //Don't bother if the unit is not an Ultralisk
});
}}}

== `getNearestTarget` ==

{{{
static CUnit* getNearest(int x, int y, int left, int top, int right, int bottom, UnitFinderCallbackMatchInterface &callback);
static CUnit* getNearest(int x, int y, UnitFinderCallbackMatchInterface &callback);
}}}

Returns the unit nearest to (`x`, `y`) for which `callback.match()` returns `true`, using the given map bounds (`left`, `top`, `right`, `bottom`). If there are no matches, returns `NULL`.

The 3-parameter version searches the entire map. Depending on the number of units in the game, it may be significantly slower than the version that uses custom search boundaries.

_Note: This does NOT take unit size into account when calculating distance._

_Note: This is a static member function, and does NOT require an instance of the class._

=== Parameters ===
 * `x`, `y`: The "goal" of the search point.
 * `left`, `top`, `right`, `bottom`: Specifies the search bounds on the map. If omitted, the function searches the entire map.
 * `callback`: A callback class that inherits from the `UnitFinderCallbackMatchInterface ` class.